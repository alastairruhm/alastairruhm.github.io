<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>https://alastairruhm.github.io/index.xml</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 12 Jun 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://alastairruhm.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>监控系统 push 和 pull 模型</title>
      <link>https://alastairruhm.github.io/post/push-vs-pull-monitoring/</link>
      <pubDate>Mon, 12 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://alastairruhm.github.io/post/push-vs-pull-monitoring/</guid>
      <description>

&lt;h1 id=&#34;监控系统-push-和-pull-模型&#34;&gt;监控系统 push 和 pull 模型&lt;/h1&gt;

&lt;h2 id=&#34;push-模型&#34;&gt;Push 模型&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var fooCount = 0

func foo() {
    // ... do stuff ...

    fooCount += 1
    metricsChan &amp;lt;- Metrics{&amp;quot;foo.count&amp;quot;, fooCount, CounterType}
}

var metricsChan = make(chan Metrics, 1000)

func metricsPusher() { // run as a goroutine
    for m := range metricsChan {
        // send m to the monitoring system
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;push 模型需要处理的一些问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Service Discovery: How does the application know where the monitoring system is located? For example, if you are reporting metrics to a StatsD server, all your app instances should know the StatsD server hostname/IP.&lt;/li&gt;
&lt;li&gt;Retry Policy: The sender should have some logic to handle intermittent network disruptions and delays.&lt;/li&gt;
&lt;li&gt;Backlog Management: In the pseudo-code above, the buffered channel had a size of 1000. When dealing with high metric volume, the sender should actively manage this backlog. Cases like production rate higher than dispatch rate, backlog filling up and memory consumption of backlog should be handled.&lt;/li&gt;
&lt;li&gt;Batching: For most systems, it is efficient to batch multiple requests into one, thereby avoiding multiple round trips. The sender should make use of batching if possible.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;pull-模型&#34;&gt;Pull 模型&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;import _ &amp;quot;expvar&amp;quot;

var fooCount = expvar.NewInt(&amp;quot;foo.count&amp;quot;)

func foo() {
    // ... do stuff ...

    fooCount.Add(1)
}

func main() {
    http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil)
    // http://localhost:8080/debug/vars has the metrics
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pull 模型的一些不同于 push 的特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Lower Application Cost: The cost of memory and CPU at application side is proportional to the number of metrics, not the rate of production of metrics.&lt;/li&gt;
&lt;li&gt;No Application-side Service Discovery: The task of discovering the HTTP endpoints to be monitored is shifted to the monitoring system side.&lt;/li&gt;
&lt;li&gt;Risk of Lost Outliers: If an outlier occurs within two pulls, it will be missed by the monitoring system.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No Events&lt;/strong&gt;: Typically, it is not possible to report one-shot events (like a “reload” or “deploy”) using the pull mechanism.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;两类模型的代表&#34;&gt;两类模型的代表&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;prometheus 是典型的基于 pull 模型的监控系统，但是它也可以通过 pushgateway 组件支持 push 模型&lt;/li&gt;
&lt;li&gt;StatsD has mostly become the defacto standard for the push method of reporting metrics.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Golang 标准库中的 expvar 包常用来暴露 app 中的 metrics&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;furthur-reading&#34;&gt;furthur reading&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.opsdash.com/blog/golang-app-monitoring-statsd-expvar-prometheus.html&#34;&gt;Go App Monitoring: expvar, Prometheus and StatsD - OpsDash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.influxdata.com/monitoring-with-push-vs-pull-influxdb-adds-pull-support-with-kapacitor/&#34;&gt;InfluxData Kapacitor 1.3 | Monitoring Push vs Pull and The Support of Both&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gocn.io/question/373&#34;&gt;监控系统中到底是pull还是push方案好？ - Go 技术社区 - golang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>git 通过代理加速</title>
      <link>https://alastairruhm.github.io/post/git-acceleration/</link>
      <pubDate>Mon, 07 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://alastairruhm.github.io/post/git-acceleration/</guid>
      <description>

&lt;h1 id=&#34;git-通过代理加速&#34;&gt;git 通过代理加速&lt;/h1&gt;

&lt;p&gt;github 访问受限，导致 clone / push 等操作速度很慢。以下是两个加速的方法以及缺陷和对比&lt;/p&gt;

&lt;h2 id=&#34;https&#34;&gt;https&lt;/h2&gt;

&lt;p&gt;github 允许用户通过 &lt;code&gt;https&lt;/code&gt; 端口使用 &lt;code&gt;ssh&lt;/code&gt;，可以通过下面的指令测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -T -p 443 git@ssh.github.com
Hi username! You&#39;ve successfully authenticated, but GitHub does not
provide shell access.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果测试不通过，就需要修改配置文件 &lt;code&gt;~/.ssh/config&lt;/code&gt;，增加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host github.com
  Hostname ssh.github.com
  Port 443
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;优点&#34;&gt;优点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http&lt;/code&gt; 和 &lt;code&gt;https&lt;/code&gt; 代理是非常常见的，比如我一般都是对系统全局代理&lt;/li&gt;
&lt;li&gt;配置比较简单&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;因为走的是 &lt;code&gt;https&lt;/code&gt; 协议，那么在github认证时只能使用提供 username/password 的方式认证，如果要避免每次push时都输入密码，需要一些额外的步骤。&lt;a href=&#34;https://help.github.com/articles/caching-your-github-password-in-git/&#34;&gt;Caching your GitHub password in Git - User Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;另外如果开启了 &lt;code&gt;two-factor authentication&lt;/code&gt;，还需要提供 &lt;code&gt;personal access token&lt;/code&gt;。&lt;a href=&#34;https://help.github.com/articles/https-cloning-errors/#provide-access-token-if-2fa-enabled&#34;&gt;Provide access token if 2FA enabled - User Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多详情参考 &lt;a href=&#34;https://help.github.com/articles/using-ssh-over-the-https-port/&#34;&gt;Using SSH over the HTTPS port - User Documentation&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ssh&#34;&gt;ssh&lt;/h2&gt;

&lt;p&gt;前提：需要一个 socks5 代理&lt;/p&gt;

&lt;p&gt;如果是直接通过 &lt;code&gt;ssh&lt;/code&gt; 协议访问，则需要按照以下步骤配置&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;/usr/local/bin&lt;/code&gt; 增加一个文件，名为 &lt;code&gt;git-proxy-wrapper&lt;/code&gt;，增加 +x 权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ruhm@mac:~$ cat /usr/local/bin/git-proxy-wrapper
#! /bin/bash
nc -xlocalhost:1080 -X5 $*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，上面需要本机在 &lt;code&gt;1080&lt;/code&gt; 端口打开 &lt;code&gt;socks5&lt;/code&gt; 代理，端口可以自定义&lt;/p&gt;

&lt;p&gt;&lt;code&gt;~/.ssh/config&lt;/code&gt; 配置文件中内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host github.com
    hostname github.com
    User xxxxx
    IdentityFile ~/.ssh/xxxxxx
    ProxyCommand /usr/local/sbin/git-proxy-wrapper &#39;%h %p&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;优点-1&#34;&gt;优点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ssh 认证不需要提供用户名和密码&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;缺点-1&#34;&gt;缺点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;需要一个 &lt;code&gt;socks5&lt;/code&gt; 代理&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/23315073&#34;&gt;有何方法可以给github远程仓库的push提速？ - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/goncha/4591538&#34;&gt;Git and socks5 proxy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>